use NONE;
use true;
use false;

/* core types (keep in sync with `BuiltInType`) */

struct void {}
struct bool {}

struct int {}
struct reg {}
struct f64 {}

struct Str {}
struct Vec {}
struct Map {}

struct type_ref {}
struct func_ref {}
struct name {}

/* core type methods */

fn dump(self: any) -> Str;
fn different(self: any, other: any) -> bool;
fn greater(self: any, other: any) -> bool;
fn equal(self: any, other: any) -> bool;
fn less(self: any, other: any) -> bool;

fn negate(self: any) -> any {
    0 - self
}

impl void {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;
}

impl bool {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;
}

impl int {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    fn negate;
    fn abs(self: int) -> any_int;
    fn add(self: int, other: any_num) -> any_num;
    fn clamp(self: int, min: int, max: int) -> int;
    fn subtract(self: int, other: any_num) -> any_num;
}

impl reg {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    fn add(self: reg, other: any_num) -> any_num;
    fn clamp(self: reg, min: reg, max: reg) -> reg;
    fn subtract(self: reg, other: any_num) -> any_num;
}

impl f64 {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    fn negate;
    fn abs(self: f64) -> f64;
    fn add(self: f64, other: any_num) -> any_num;
    fn clamp(self: f64, min: f64, max: f64) -> f64;
    fn subtract(self: f64, other: any_num) -> any_num;

    fn round(self: f64) -> any_int;
    fn floor(self: f64) -> any_int;
    fn ceil(self: f64) -> any_int;
    fn fract(self: f64) -> f64;
}

impl Str {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    /* fn bytes(self: Str) -> bytes; */
    /* fn chars(self: Str) -> Vec; */
    fn add(self: Str, other: Str) -> Str;
}

impl Vec {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    fn add(self: Vec, other: Vec) -> Vec;
    fn len(self: Vec) -> reg;
    fn get(self: Vec, index: any_int) -> any;
    fn has(self: Vec, index: any_int) -> bool;
    fn set(self: Vec, index: any_int, value: any) -> any;

    fn iter(self: Vec) -> VecIter {
        VecIter {
            vec: self,
            index: 0,
        }
    }
}

impl Map {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;

    fn len(self: Vec) -> reg;
    fn get(self: Map, key: any) -> any;
    fn has(self: Map, key: any) -> bool;
    fn nth_key(self: Map, index: any_int) -> any;
    fn nth_value(self: Map, index: any_int) -> any;
    fn set(self: Map, key: any, value: any) -> any;

    fn iter(self: Map) -> EntryIter {
        EntryIter {
            map: self,
            index: 0,
        }
    }
}

impl type_ref {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;
}

impl func_ref {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;
}

impl name {
    fn dump;
    fn different;
    fn greater;
    fn equal;
    fn less;
}

/* iterators */

fn range(start: int, limit: int) -> NumIter {
    NumIter {
        i: start,
        limit: limit,
    }
}

fn avoid(iter: any, avoided: any) -> AvoidIter {
    if avoided == NONE {
        println("avoided cannot be void");
        return;
    };

    AvoidIter {
        base: iter,
        avoided,
    }
}

fn map(iter: any, mapper: func_ref) -> MapperIter {
    MapperIter {
        base: iter,
        mapper,
    }
}

fn take(iter: any, num: any_int) -> TakeIter {
    TakeIter {
        base: iter,
        remaining: num,
    }
}

fn until(iter: any, end: any) -> UntilIter {
    UntilIter {
        base: iter,
        end,
        reached: false,
    }
}

fn chain(a: any, b: any) -> ChainedIter {
    ChainedIter {
        a,
        b,
        switched: false,
    }
}

fn contains(iter: any, value: any) -> bool {
    locate(iter, value) != NONE
}

fn locate(iter: any, value: any) -> reg | void {
    let i = 0;

    for item in iter {
        if item == value {
            return i;
        };

        i = i + 1;
    }
}

fn find(iter: any, func: func_ref) -> any {
    for item in iter {
        if func(item) {
            return item;
        };
    }
}

fn skip(iter: any, num: any_int) -> any {
    while num > 0 {
        iter.next();
    }

    iter
}

struct NumIter {
    i: int,
    limit: int,
}

impl NumIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: NumIter) -> int | void {
        let then = self.i;

        if then < self.limit {
            self.i = then + 1;
            then
        } else {
            NONE
        }
    }
}

struct Entry {
    key: any,
    value: any,
}

struct EntryIter {
    map: Map,
    index: reg,
}

impl EntryIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: EntryIter) -> any {
        let next = self.index + 1;
        let key = self.map.nth_key(self.index);

        if key == NONE {
            return NONE;
        };

        let value = self.map.nth_value(self.index);
        self.index = next;

        Entry { key, value, }
    }
}

struct VecIter {
    vec: Vec,
    index: reg,
}

impl VecIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: VecIter) -> any {
        let next = self.index + 1;
        let value = self.vec.get(self.index);

        if value != NONE {
            self.index = next;
        };

        value
    }
}

struct AvoidIter {
    base: any,
    avoided: any,
}

impl AvoidIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: AvoidIter) -> any {
        let next = self.base.next();

        while next == self.avoided {
            next = self.base.next();
        }

        next
    }
}

struct MapperIter {
    base: any,
    mapper: any,
}

impl MapperIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: MapperIter) -> any {
        let next = self.base.next();

        if next != NONE {
            next = self.mapper.map(next);
        };

        next
    }
}

struct TakeIter {
    base: any,
    remaining: reg,
}

impl TakeIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: TakeIter) -> any {
        if self.remaining == 0 {
            return NONE;
        };

        self.remaining = self.remaining - 1;
        self.base.next()
    }
}

struct UntilIter {
    base: any,
    end: any,
    reached: bool,
}

impl UntilIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: UntilIter) -> any {
        if self.reached {
            return;
        };

        let item = self.base.next();

        if item == self.end {
            self.reached = true;
            return;
        };

        item
    }
}

struct ChainedIter {
    a: any,
    b: any,
    switched: bool,
}

impl ChainedIter {
    fn avoid;
    fn map;
    fn take;
    fn until;
    fn chain;
    fn contains;
    fn locate;
    fn find;
    fn skip;

    fn next(self: ChainedIter) -> any {
        if self.switched {
            return self.b.next();
        };

        let item = self.a.next();

        if item == NONE {
            self.switched = true;
            return self.b.next();
        };

        item
    }
}

/* misc types */

fn println();

type any_int = reg | int;
type any_num = reg | int;

/* todo

type opt_len = reg | void;

struct byte_r {}
struct byte_w {}

struct socket {
    reader: byte_r,
    writer: byte_w,
}

impl byte_r {
    fn available(self: byte_r) -> opt_len;

    fn read_bytes(self: byte_r, len: opt_len) -> bytes;
    fn read_until(self: byte_r, token: Str) -> Str;
    fn read_str(self: byte_r, len: opt_len) -> Str;

    fn read_u8(self: byte_r) -> reg;
    fn read_u16(self: byte_r) -> reg;
    fn read_u32(self: byte_r) -> reg;
    fn read_u64(self: byte_r) -> any_int;

    fn read_i8(self: byte_r) -> int;
    fn read_i16(self: byte_r) -> int;
    fn read_i32(self: byte_r) -> int;
    fn read_i64(self: byte_r) -> int;
}

impl byte_w {
    fn write_bytes(self: byte_w, data: Vec | bytes);
    fn write_str(self: byte_w, data: Str);

    fn write_u8(self: byte_w, data: reg);
    fn write_u16(self: byte_w, data: reg);
    fn write_u32(self: byte_w, data: reg);
    fn write_u64(self: byte_w, data: reg);

    fn write_i8(self: byte_w, data: int);
    fn write_i16(self: byte_w, data: int);
    fn write_i32(self: byte_w, data: int);
    fn write_i64(self: byte_w, data: int);
}

fn open_r(path: Str) -> byte_r;
fn open_w(path: Str) -> byte_w;

fn resolve(name: Str) -> Str;
fn connect_tcp(ip: Str, port: any_int) -> socket;
fn connect_tls(ip: Str, port: any_int) -> socket;

*/
